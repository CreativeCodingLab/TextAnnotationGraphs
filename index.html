<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="css/style.css" rel="stylesheet">
</head>

<body>

<div id="header">
  <select id="dataset">
    <option>-- select dataset --</option>
    <option>data1</option>
    <option>data2</option>
    <option>paragraph</option>
    <option>passage</option>
  </select>

  <div id="collapse" style="display:inline; float:right;">
    <button>[</button>
    <button>]</button>
  </div>
</div>

<div id="minimap" class="noselect">
  <a id="toggle-minimap">hide>></a>
  <input type="text" id="search-minimap">
  <canvas>
  </canvas>
</div>

<div id="drawing">
</div>
<div id="graph">
</div>


<script src="libs/d3.min.js"></script>
<script src="libs/svg.js"></script>
<script src="libs/svg.draggable.js"></script>
<script src="libs/lodash.js"></script>
<script src="libs/chroma.min.js"></script>

<script src="js/enums.js"></script>
<script src="js/config.js"></script>
<script src="js/parser.js"></script>
<script src="js/Panel.js"></script>
<script src="js/GraphLayout.js"></script>
<script src="js/style.js"></script>
<script src="js/word.js"></script>
<script src="js/link.js"></script>
<script src="js/row.js"></script>
<script src="js/annotate.js"></script>
<script src="js/render.js"></script>
<script src="js/interact.js"></script>
<script src="js/utils.js"></script>
<script src="js/minimap.js"></script>

<script type="text/javascript">
/* a lot of these global vars should be wrapped eventually */
var draw = SVG('drawing').size(Config.svgWidth, Config.svgHeight);
var rowGroup = draw.group();
var groupAllElements;
var linkG, textG, arrowG;
var dragElem = null;
var isDragging = false;

var styles = setupStyles(draw); //creates an associative array of whatever styles you want to make use of later

var texts = setupTexts(draw); //creates an associate array of whatever text you want to use. Currently using 'texts.wordText' and 'texts.linkText', and using style, maxHeight, and descent to layout text

Config.handleH = texts.wordText.maxHeight + (Config.textPaddingY * 2);
Config.wordHeight = texts.wordText.maxHeight + (Config.textPaddingY * 2); 
Config.minWordWidth = Math.max( getTextWidthAndHeight("i", texts.wordText.style).w + (Config.handleW * 2), getTextWidthAndHeight("i", texts.tagText.style).w + (Config.handleW * 2) );

var rowOffsetX = 0;
var rowOffsetWord = null;

var rows = []; //list of Row object, each of those has a list of Word objects

// 1. create Words and Links objects (in utils.js) */
var wordObjs = createTestWords(4, 10, 10);

var linkObjs = createTestMultiLinks(1); 

drawWords(wordObjs);
drawLinks(linkObjs);

changeSizeOfSVGPanel(window.innerWidth - 16, (rows[rows.length - 1].lineBottom.y() ) + 1);

window.onload = function() {

  const minimap = new Minimap();

  const panel = new Panel('graph', 'drawing');
  const graph = new GraphLayout(panel.el);
  panel.onresize = graph.resize.bind(graph);
  const parser = new Parser();

  var prevWidth = Config.svgWidth;
  function svgResize() {
    var widthPercChange; 
    Config.svgWidth = (window.innerWidth - 16);
    changeSizeOfSVGPanel(Config.svgWidth, draw.height());
    widthPercChange = Config.svgWidth / prevWidth;
    prevWidth = Config.svgWidth;
    recalculateRows(widthPercChange); //makes sure that the words fit in the current width, else makes new rows  
  }

  function getSelectedObjects() {
    return wordObjs.concat(linkObjs).filter(obj => obj.isSelected);
  }

  draw.on('wordSelected', function() {
    graph.graph(getSelectedObjects());
  });

  function changeDataset(index = 1) {
    parser.readJson(`./data/data${index}.json`, function() {
      graph.clear();

      // construct word objects and tags from tokens, entities, and triggers
      const words = parser.tokens.map((token, i) => new Word(token, i));

      [].concat(parser.data.entities, parser.data.triggers).forEach(el => {
        if (words[el.tokenIndex]) {
          words[el.tokenIndex].tag = el.type;
          words[el.tokenIndex].eventId = el.id;
        }
      });
      wordObjs = words;

      // construct links from events and relations
      const links = [];
      parser.data.events.forEach(evt => {
        const trigger = words.find(word => word.eventId === evt.trigger);

        // create a link between the trigger and each of its arguments
        evt.arguments.map(arg => {
          let anchor;
          switch (arg.id.charAt(0)) {
            case 'E':
              anchor = links.find(link => link.eventId === arg.id);
              break;
            case 'T': 
              anchor = words.find(word => word.eventId === arg.id);
              break;
            default:
              console.log('unhandled argument type', arg);
              break;
          }

          // style the arrow
          const ltr = arg.type !== 'Controller';
          const direction = ltr ? [1, -1] : [-1, 1];
          const arrowType = arg.type === 'Theme' ? styles.simpleLine : ltr ? styles.gradientLine1 : styles.gradientLine1r;

          // create link
          const link = new Link(
            [trigger, anchor],
            direction,
            arrowType,
            arg.type,
            texts.linkText
          );
          link.eventId = evt.id;

          // push link to link array
          links.push(link);
          createLink(link);

        });//evt.argument.map
      });//parser.data.events.forEach

      parser.data.relations.forEach(rel => {
        let ltr = true;
        const arguments = rel.arguments.map((arg, i) => {
          let anchor;
          switch (arg.id.charAt(0)) {
            case 'E':
              anchor = links.find(link => link.eventId === arg.id);
              break;
            case 'T': 
              anchor = words.find(word => word.eventId === arg.id);
              break;
            default:
              console.log('unhandled argument type', arg);
              break;
          }
          if (arg.type === 'Controlled' && i > 0) {
            ltr = false;
          }
          return anchor;
        });

        // create link
        const link = new Link(
          arguments,
          ltr ? [-1, 1] : [1, -1],
          ltr ? styles.gradientLine2 : styles.gradientLine2r,
          rel.type,
          texts.linkText
        );

        // push link to link array
        links.push(link);
        createLink(link);
      });

      resetDrawing(words, links);
    });
  };

  function resetDrawing(words, links) {
    draw.children().forEach(child => {
      if (child.type !== 'defs') {
        child.remove();
      }
    });
    rowGroup = draw.group();
    groupAllElements = linkG = textG = arrowG = undefined;
    isDragging = false;
    rowOffsetX = 0;
    rowOffsetWord = null;
    dragElem = null;

    rows = [];
    wordObjs = words || createTestWords(5, 6, 10);
    linkObjs = links || createTestMultiLinks(1);
    drawWords(wordObjs);
    drawLinks(linkObjs);
    changeSizeOfSVGPanel(window.innerWidth - 16, (rows[rows.length - 1].lineBottom.y() ) + 1);
  }

  function resize() {
    svgResize();
    graph.resize();
  }

  document.getElementById('dataset').onchange = function() {
    Config.redraw = 0;
    if (this.selectedIndex > 0) {
      changeDataset(this.selectedIndex);
    }
  };
  window.onresize = _.debounce(resize, 300);

  changeDataset(2);
};

</script>


</body>
</html>


<html>
<head>

<!-- turns off text selection for svg canvas -->
<style>
body {
  margin:0;
  -moz-osx-font-smoothing:grayscale;
  -webkit-font-smoothing:antialiased;
}

svg text {
  cursor: default;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

#header {
  position:absolute;
  top:0;
  left:0;
  background:#333;
  color:white;
  width:calc( 100% - 20px );
  padding:10px;
}

#drawing {
  margin-top:30px;
}

button {
  background:white;
  border:none;
  outline:none;
}

button.active {
  background:#ff8;
}

.split-left {width:66.5%; overflow:hidden;}
.split-right {transform:translateX(0) !important;}
.node { cursor: pointer; }
#graph {
    transition:transform 200ms ease;
    transform:translateX(100%);
    width:33%;
    height:100%;
    background:#fafaea;
    position:fixed;
    top:0;
    right:0;
}

</style>

</head>

<body>

<div id="header">
  <input type="file">
  <button class="active" id="POS">POS</button>
  <button id="BIO">BIO</button>
</div>

<div id="drawing">

</div>
 

<script src="libs/d3.min.js"></script>
<script src="libs/svg.js"></script>
<script src="libs/svg.draggable.js"></script>
<script src="libs/lodash.js"></script>
<script src="libs/chroma.min.js"></script>

<script src="js/GraphLayout.js"></script>
<script src="js/enums.js"></script>
<script src="js/style.js"></script>
<script src="js/annotate.js"></script>
<script src="js/render.js"></script>
<script src="js/interact.js"></script>
<script src="js/utils.js"></script>

<script type="text/javascript">

/* a lot of these global vars should be wrapped eventually */

var debug = true;

var svgWidth = window.innerWidth - 16;
var svgHeight = 1000;



var evenRowsColor = '#efeff4';
var oddRowsColor = '#dddddf';
var rowEdgeColor = 'transparent';

//var draw = SVG('drawing').size('100%', '100%');
var draw = SVG('drawing').size(svgWidth, svgHeight)
            // .attr('viewBox', '0 0 ' + svgWidth + ' ' + svgHeight);

var rowGroup = draw.group();
var groupAllElements;
var linkG, textG, arrowG;

//var gradientDefGroup = draw.defs().group();

var styles = setupStyles(draw); //creates an associative array of whatever styles you want to make use of later

var texts = setupTexts(draw); //creates an associate array of whatever text you want to use. Currently using 'texts.wordText' and 'texts.linkText', and using style, maxHeight, and descent to layout text

var dragElem = null;
var isDragging = false;

var levelpadding = 16;
var /*textpadding */ textpaddingX = 8;//12; //this is the x-padding within each word rect, between the text and the rectangle it's inside of
var textpaddingY = 6;//texts.wordText.maxHeight / 2; //padding above and below text, between text and rectangle it's inside of
var wordpadding = 4; //x padding between the rects containing words
//var topMargin = 0;
var edgepadding = 10; //padding between left side of svg canvas and where first word can be placed, and padding between right side of svg canvas and where last word on a row can fit (before popping over to next row)
var rowpadding = 30;

var hideLinkLinesPercentage = 3.0; //percentage at which links and arrows are hidden
var hideLinkTextPercentage = 7.0; //percentage at which words are link words are hidden



var handleW = 10;
var handleH = texts.wordText.maxHeight + (textpaddingY * 2);
var handleColor = '#ff0000';
var handleOpacity= 0.1;

//should be able to remove these hardcoded vals - moved this logic to style.js, arrow functions. Looks like intereact.js dragArrow still uses them, should be able to remove...
var arrowH = 5; //9;
var arrowMH = 5; //7; //4
var arrowW = 3; //3

var wordHeight = texts.wordText.maxHeight + (textpaddingY * 2); 
var minWordWidth = Math.max( getTextWidthAndHeight("i", texts.wordText.style).w + (handleW * 2), getTextWidthAndHeight("i", texts.tagText.style).w + (handleW * 2) );


var evenRowsColor_selected = '#cdcdff';
var oddRowsColor_selected = '#bbbbff';
var dragRectSide = 8;
var dragRectMargin = 1;

var rowOffsetX = 0;
var rowOffsetWord = null;
var dragDir = directions.NONE;
var prevX = -1;

var linkStrokeThickness = 1.5;
var linkStrokeColor = '#cc9999';
var linkStrokeOpacity = 1.0;

var linkStrokeThickness_selected = 1.5;
var linkStrokeColor_selected = '#449944';
var linkStrokeOpacity_selected = 1.0;

var attachmentMargin = 0.1; //percentage value

var word2word_strategy = strategies.FARTHEST;
var word2link_strategy = strategies.FARTHEST; 
var link2link_strategy = strategies.FARTHEST; //CLOSEST sometimes causes overlaps - need to be a bit more rigorous when assigning slots - don't assign any slots that have the potential to overlap (when dragged manually)? - or let the buyer beware that this could happen - they can always move out of the way - right now it won't automatically overlap, but won't prevent a user from doing it. 

var rows = []; //list of Row object, each of those has a list of Word objects

</script>

<script>

/* these should eventually be made non-global too */
var wordObjs = [], linkObjs = [];

// init objects/listeners...
window.onload = function() {

  // init buttons
  const State = {
    annotationStyle: document.querySelector('button.active').id,
    setAnnotationStyle: function(type) {
      this.annotationStyle = type;
    }
  };
  const buttons = document.querySelectorAll('#header button');
  buttons.forEach(function(clickableButton) {
    clickableButton.onclick = function() {
      buttons.forEach(button => {
        button.classList.toggle('active', button == this);
      })
      State.setAnnotationStyle(this.id);
    }
  });

  /* load JSON file */
  var json = './data/angus-ex.json';

  function loadJSON(path, callback) {
      var httpRequest = new XMLHttpRequest();
      httpRequest.onreadystatechange = function() {
          if (httpRequest.readyState === 4) {
              if (httpRequest.status === 200) {
                  var data = JSON.parse(httpRequest.responseText);
                  if (callback) callback(data);
              }
          }
      };
      httpRequest.open('GET', path);
      httpRequest.send(); 
  }

  /* parse json file*/
  loadJSON(json, parseData);

  /** init words and links from json data
   *  - first hierarchy:  documents--sentences--words (+associated syntax tags)
   *  -                   edges connect parts of speech
   *  - second hierarchy: events--paths | arguments--themes
   */
  function parseData(data) {
    console.log(data);

    let datamap = {}; // map Word instances to indices in data

    for (var i in data.documents) {
        let doc = data.documents[i];

        doc.sentences.forEach( function(sentence, j) {
            // generate words
            sentence.words.forEach( function(word, k) {
                let idx = wordObjs.length;
                let w = new Word(word, idx);
                w.documentId = i;
                w.syntaxData = {
                  tag: sentence.tags[k],
                  lemma: sentence.lemmas[k],
                  entity: sentence.entities[k]
                }
                w.tag = w.syntaxData.tag;
                wordObjs.push(w);
                datamap[i + '-' + j + '-' + k + '-' + word] = idx;
            })

            // create links from syntax info
            let syntaxType = "stanford-collapsed"; /* "stanford-basic */
            sentence.graphs[syntaxType].edges.forEach(function(edge) {

                let sourceWord = sentence.words[edge.source],
                    destinationWord = sentence.words[edge.destination];

                let sourceIndex = datamap[i + '-' + j + '-' + edge.source + '-' + sourceWord],
                    destinationIndex = datamap[i + '-' + j + '-' + edge.destination + '-' + destinationWord];

                let style;
                switch (edge.relation) {
                  case 'nsubj':
                    style = styles.gradientLine1; break;
                  case 'dobj':
                    style = styles.gradientLine2; break;
                  default:
                    style = styles.noneLine; break;
                }

                linkObjs.push( new Link(
                  wordObjs[sourceIndex],
                  wordObjs[destinationIndex], 
                  sourceIndex < destinationIndex ? 1 : -1, 
                  style, 
                  edge.relation, 
                  texts.linkText
                ) );
            })
        })
    }

    // create links from event info
    data.mentions.forEach((mention, i) => {
        console.log('\tmention triggered by "' + mention.trigger.text + '"');
        console.log('\tevent', mention.trigger.labels[0]);
        console.log('\tid', mention.trigger.id);
        console.log('\tinterval', mention.tokenInterval.start, mention.tokenInterval.end, '[range of words influenced by event)');

        console.log('\n\targuments:');
        for (var a in mention.arguments) {
            console.log('\t\t' + a);

            function listArguments(arg, count) {
                let space = new Array(count).join('\t');
                console.log(space + ' text', arg.text);
                console.log(space + ' label', arg.labels[0]);
                console.log(space + ' id', arg.id);
                if (arg.arguments) {
                    console.log(space + ' arguments:')
                }
                for (var i in arg.arguments) {
                    console.log(space + '\t' + i);
                    arg.arguments[i].forEach(l => listArguments(l, count+2));
                }                    
            }

            mention.arguments[a].forEach(l => listArguments(l, 4));
        }

        console.log('\n\tpaths:');
        for (var p in mention.paths) {
            console.log('\t\t' + p);
            for (var pathId in mention.paths[p]) {
                console.log('\t\t\t id ' + pathId);
                mention.paths[p][pathId].forEach(path => {
                    let words = data.documents[mention.document].sentences[mention.sentence].words;
                    console.log('\t\t\t\t edge', words[path.source] + ' -> ' + path.relation + ' -> ' + words[path.destination]);
                })
            }
        }
    })


    linkObjs.sort(function(a, b) {
      var d1 = Math.abs(a.s.idx - a.e.idx);
      var d2 = Math.abs(b.s.idx - b.e.idx);

      return d1 - d2; 
    });

    linkObjs.forEach(createLink);


    // 2. draw words and boxes around words
    drawWords(wordObjs);

    // 3. draw each of the links
    drawLinks(linkObjs);

    changeSizeOfSVGPanel(window.innerWidth - 16, (rows[rows.length - 1].lineBottom.y() ) + 1);

  }


  /* init graph layout object */
  var Panel = new GraphLayout();
  var prevWidth = svgWidth;

  function svgResize() {
    var w, widthPercChange; 
    if (Panel.isOpen) {

      svgWidth = (window.innerWidth - 16) * 0.665;

      changeSizeOfSVGPanel(svgWidth, draw.height());

      //draw.size(svgWidth, draw.height());
    }
    else {
      svgWidth = (window.innerWidth - 16)
      changeSizeOfSVGPanel(svgWidth, draw.height());


     //   draw.size(svgWidth, draw.height());

    }

    widthPercChange = svgWidth / prevWidth;
    prevWidth = svgWidth;
    //console.log("\nwidthPercChange = " + widthPercChange);


    recalculateRows(widthPercChange); //makes sure that the words fit in the current width, else makes new rows
  
  }

  document.addEventListener('keydown',
    function(e) {
      var key = e.keyCode || e.which;
      // console.log('keycode',key);
      switch(key) {
        case 37:          // left arrow
          if (Panel.isOpen) {
            Panel.close();
            svgResize();
          }
          break;
        case 39:          // right arrow
          if (!Panel.isOpen) {
            Panel.open();
            svgResize();
          }
          Panel.graph(wordObjs.filter(word => word.isSelected));
          break;
        default:
          break;
      }
    }, false);

  function resize() {
    svgResize();
    Panel.resize();
  }

  window.onresize = _.debounce(resize, 300);
}

</script>


</body>
</html>

